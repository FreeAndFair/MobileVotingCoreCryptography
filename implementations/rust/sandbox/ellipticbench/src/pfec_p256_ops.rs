/*
 * p-256 pfec benchmark code
 *
 * @author David Ruescas (david@sequentech.io)\
 * @copyright Free & Fair. 2025\
 * @version 0.1
 */

use elgamal_p256::algebra::groups::inst::pfec_group_p256;
use elgamal_p256::algebra::groups::inst::pfec_group_p256::Inimportat32point;
use num::bigint::{BigInt, Sign};
use p256::Scalar;
use p256::elliptic_curve::Field;
use rand::RngCore;
use rand::rngs::ThreadRng;

pub fn random_scalar(rng: &mut ThreadRng) -> Scalar {
    Scalar::random(rng)
}

// generating a random point by try and increment encoding is not uniform but we don't care
pub fn random_point() -> Inimportat32point {
    let bigint = generate_random_bigint_up_to(247);
    let bv = elgamal_p256::dword::DWord::from_int(247, &bigint);
    pfec_group_p256::enc(bv.as_ref())
    // pfec_group_p256::in_import_at__32_enc_bits_inst_sz_sz(242, 15, bv.as_ref())
}

pub fn multiply_generator(exponent: BigInt) -> Inimportat32point {
    pfec_group_p256::in_import_at__32_scmul(&exponent, &pfec_group_p256::g)
}

pub fn multiply_random_point(point: &Inimportat32point, exponent: BigInt) -> Inimportat32point {
    pfec_group_p256::in_import_at__32_scmul(&exponent, point)
}

fn random_pfec_scalar(random_scalar: &Scalar) -> BigInt {
    let scalar_bytes = random_scalar.to_bytes();
    BigInt::from_bytes_be(Sign::Plus, &scalar_bytes)
}

pub fn bench_generator_multiplication(iterations: usize) -> (f64, f64, f64) {
    let mut rng = rand::thread_rng();
    let scalars: Vec<Scalar> = (0..iterations).map(|_| random_scalar(&mut rng)).collect();
    let mut times = Vec::with_capacity(iterations);

    for scalar in &scalars {
        let exponent_bigint = random_pfec_scalar(scalar);
        let start = crate::utils::now();
        let _result = multiply_generator(exponent_bigint);
        let duration = start.elapsed();
        times.push(duration.as_micros() as f64 / 1000.0);
    }

    let avg = times.iter().sum::<f64>() / times.len() as f64;
    let min = *times
        .iter()
        .min_by(|a, b| a.partial_cmp(b).unwrap())
        .unwrap();
    let max = *times
        .iter()
        .max_by(|a, b| a.partial_cmp(b).unwrap())
        .unwrap();

    (avg, min, max)
}

pub fn bench_random_point_multiplication(iterations: usize) -> (f64, f64, f64) {
    let mut rng = rand::thread_rng();
    let points: Vec<Inimportat32point> = (0..iterations).map(|_| random_point()).collect();
    let scalars: Vec<Scalar> = (0..iterations).map(|_| random_scalar(&mut rng)).collect();
    let mut times = Vec::with_capacity(iterations);

    for i in 0..iterations {
        let exponent_bigint = random_pfec_scalar(&scalars[i]);
        let start = crate::utils::now();
        let _result = multiply_random_point(&points[i], exponent_bigint);
        let duration = start.elapsed();
        times.push(duration.as_micros() as f64 / 1000.0);
    }

    let avg = times.iter().sum::<f64>() / times.len() as f64;
    let min = *times
        .iter()
        .min_by(|a, b| a.partial_cmp(b).unwrap())
        .unwrap();
    let max = *times
        .iter()
        .max_by(|a, b| a.partial_cmp(b).unwrap())
        .unwrap();

    (avg, min, max)
}

fn generate_random_bigint_up_to(bits: u64) -> BigInt {
    if bits == 0 {
        return BigInt::from(0);
    }

    // Determine the number of bytes needed to hold the specified number of bits.
    // The `+ 7` is a common trick to round up to the nearest whole byte.
    let num_bytes = ((bits + 7) / 8) as usize;

    // Generate that many random bytes.
    let mut bytes = vec![0u8; num_bytes];
    rand::thread_rng().fill_bytes(&mut bytes);

    // Convert the bytes to a BigInt. We treat them as a big-endian positive number.
    let mut random_bigint = BigInt::from_bytes_be(Sign::Plus, &bytes);

    // The number of bits in our generated bytes might be more than requested.
    // We need to clear the excess bits to stay within the range [0, 2^bits - 1].
    // This is done by right-shifting to discard the excess high bits.
    let excess_bits = (num_bytes * 8) as u64 - bits;
    random_bigint >>= excess_bits;

    random_bigint
}

#[cfg(test)]
mod tests {

    use p256::{
        elliptic_curve::{
            bigint::Encoding, sec1::ToEncodedPoint,
        }, EncodedPoint, U256, ProjectivePoint
    };
    use super::*;

    #[test]
    fn test_pfec_g_scalar_mult() {

        const NUM_ITERATIONS: u32 = 100;
        let mut rng = rand::thread_rng();

        let pfec_generator = &pfec_group_p256::g;
        let p256_generator = ProjectivePoint::GENERATOR;

        println!(
            "\n--- Running Scalar Multiplication Test ({} iterations) ---",
            NUM_ITERATIONS
        );

        for _i in 0..NUM_ITERATIONS {

            let p256_random_scalar = random_scalar(&mut rng);
            let pfec_random_scalar = random_pfec_scalar(&p256_random_scalar);

            let pfec_result =
                pfec_group_p256::in_import_at__32_scmul(&pfec_random_scalar, pfec_generator);
            let p256_result = p256_generator * p256_random_scalar;

            let (x_pfec_raw, y_pfec_raw) = match pfec_result {
                Inimportat32point::Affine(x, y) => (x, y),
                _ => panic!("Expected a Point from pfec, got infinity"),
            };

            let (_sign_x, x_pfec_bytes) = x_pfec_raw.from_z().to_bytes_be();
            let (_sign_y, y_pfec_bytes) = y_pfec_raw.from_z().to_bytes_be();

            let y_pfec_bytes = if y_pfec_bytes.len() < 32 {
                // Pad with leading zeros if necessary
                let mut padded = vec![0u8; 32 - y_pfec_bytes.len()];
                padded.extend_from_slice(&y_pfec_bytes);
                padded
            } else {
                y_pfec_bytes
            };

            // Ensure the x coordinate is also 32 bytes
            let x_pfec_bytes = if x_pfec_bytes.len() < 32 {
                // Pad with leading zeros if necessary
                let mut padded = vec![0u8; 32 - x_pfec_bytes.len()];
                padded.extend_from_slice(&x_pfec_bytes);
                padded
            } else {
                x_pfec_bytes
            };

            let affine_rust_crypto = p256_result.to_affine();
            let encoded_point: EncodedPoint = affine_rust_crypto.to_encoded_point(false);
            let x_bytes = encoded_point.x().expect("x coordinate should exist");
            let y_bytes = encoded_point.y().expect("y coordinate should exist");

            let x_bigint = U256::from_be_slice(x_bytes);
            let y_bigint = U256::from_be_slice(y_bytes);

            let x_bytes_be_: [u8; 32] = x_bigint.to_be_bytes();
            let y_bytes_be_: [u8; 32] = y_bigint.to_be_bytes();

            assert_eq!(
                x_pfec_bytes,
                x_bytes_be_.to_vec(),
                "X coordinates do not match!"
            );
            assert_eq!(
                y_pfec_bytes,
                y_bytes_be_.to_vec(),
                "Y coordinates do not match!"
            );
        }
    }
}
