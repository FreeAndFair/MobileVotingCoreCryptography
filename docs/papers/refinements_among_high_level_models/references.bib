@online{AmazonWebServicesCedarPolicy,
  title = {The {{Cedar Policy Language}}},
  author = {{Amazon Web Services}},
  url = {https://www.cedarpolicy.com/en},
  urldate = {2025-02-20},
  file = {/Users/dmz/Zotero/storage/DQYQWYHG/en.html}
}

@online{ANSIISO,
  title = {{{ANSI}}/{{ISO C Specification Language}}},
  url = {https://frama-c.com/html/acsl.html},
  urldate = {2025-02-20},
  file = {/Users/dmz/Zotero/storage/9UVI6Y32/acsl.html}
}

@online{AnsysSCADE,
  title = {Ansys {{SCADE Suite}}},
  url = {https://www.ansys.com/products/embedded-software/ansys-scade-suite},
  urldate = {2025-02-20},
  abstract = {Explore Ansys SCADE Suite, a model-based design and development environment for mission- and safety-critical embedded software.},
  langid = {american},
  file = {/Users/dmz/Zotero/storage/3YMXHJHN/ansys-scade-suite.html}
}

@online{Asmeta,
  title = {Asmeta: {{A Framework}} for the {{Abstract State Machines}} ({{ASMs}}) {{Formal Method}}},
  author = {{Formal Methods and SE Laboratory - University of Milan Formal Methods \& Software Engineering Lab - University of Bergamo}},
  url = {https://asmeta.github.io/},
  urldate = {2025-02-20},
  file = {/Users/dmz/Zotero/storage/3T2RLZTU/asmeta.github.io.html}
}

@inproceedings{BeckCunninghamLaboratoryTeaching1989,
  title = {A Laboratory for Teaching Object Oriented Thinking},
  booktitle = {Conference Proceedings on {{Object-oriented}} Programming Systems, Languages and Applications},
  author = {Beck, K. and Cunningham, W.},
  year = {1989},
  month = sep,
  series = {{{OOPSLA}} '89},
  pages = {1--6},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/74877.74879},
  url = {https://dl.acm.org/doi/10.1145/74877.74879},
  urldate = {2025-02-20},
  abstract = {It is difficult to introduce both novice and experienced procedural programmers to the anthropomorphic perspective necessary for object-oriented design. We introduce CRC cards, which characterize objects by class name, responsibilities, and collaborators, as a way of giving learners a direct experience of objects. We have found this approach successful in teaching novice programmers the concepts of objects, and in introducing experienced programmers to complicated existing designs.},
  isbn = {978-0-89791-333-1},
  file = {/Users/dmz/Zotero/storage/XHHIJPLS/Beck and Cunningham - 1989 - A laboratory for teaching object oriented thinking.pdf}
}

@book{BjornerDomainScience2021,
  title = {Domain {{Science}} and {{Engineering}}: {{A Foundation}} for {{Software Development}}},
  shorttitle = {Domain {{Science}} and {{Engineering}}},
  author = {Bj{\o}rner, Dines},
  year = {2021},
  series = {Monographs in {{Theoretical Computer Science}}. {{An EATCS Series}}},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-030-73484-8},
  url = {https://link.springer.com/10.1007/978-3-030-73484-8},
  urldate = {2025-02-20},
  copyright = {https://www.springer.com/tdm},
  isbn = {978-3-030-73483-1},
  langid = {english},
  keywords = {Domain Engineering,Domain Science,Formal Methods,Foundations of Programming,Modeling,Ontology,Raise Specification Language (RSL),Requirements Engineering,Specification Languages}
}

@online{BjornerMostlyDines,
  title = {Mostly {{Dines Bj{\o}rner}}'s {{RAISE-related Documents}}},
  author = {Bj{\o}rner, Dines},
  url = {https://raisetools.github.io/material/papers/bjorner-raise-web.pdf},
  abstract = {This document is intended for the RAISE Web page established by Klaus Havelund.},
  langid = {english},
  keywords = {No DOI found},
  file = {/Users/dmz/Zotero/storage/8IV63DIU/Bjørner - Mostly Dines Bjørner’s RAISE-related Documents.pdf}
}

@article{BMethod2024,
  title = {B-{{Method}}},
  year = {2024},
  month = oct,
  journal = {Wikipedia},
  url = {https://en.wikipedia.org/w/index.php?title=B-Method&oldid=1253211181},
  urldate = {2025-02-20},
  abstract = {The B method is a method of software development based on B, a tool-supported formal method based on an abstract machine notation, used in the development of computer software.},
  copyright = {Creative Commons Attribution-ShareAlike License},
  langid = {english},
  annotation = {Page Version ID: 1253211181},
  file = {/Users/dmz/Zotero/storage/8669PRP4/B-Method.html}
}

@online{ClaferLightweight,
  title = {Clafer: {{Lightweight Modeling Language}}},
  url = {https://www.clafer.org/p/software.html},
  urldate = {2025-02-20},
  abstract = {On-line Tools   The following are publicly available demo installations of the web-based tools for~Clafer.   ClaferIDE  An IDE for Clafer i...},
  file = {/Users/dmz/Zotero/storage/S8R8EXJQ/software.html}
}

@article{CommunicatingSequential2024,
  title = {Communicating Sequential Processes},
  year = {2024},
  month = dec,
  journal = {Wikipedia},
  url = {https://en.wikipedia.org/w/index.php?title=Communicating_sequential_processes&oldid=1261864146},
  urldate = {2025-02-20},
  abstract = {In computer science, communicating sequential processes (CSP) is a formal language for describing patterns of interaction in concurrent systems. It is a member of the family of mathematical theories of concurrency known as process algebras, or process calculi, based on message passing via channels. CSP was highly influential in the design of the occam programming language and also influenced the design of programming languages such as Limbo, RaftLib, Erlang, Go, Crystal, and Clojure's core.async. CSP was first described by Tony Hoare in a 1978 article, and has since evolved substantially. CSP has been practically applied in industry as a tool for specifying and verifying the concurrent aspects of a variety of different systems, such as the T9000 Transputer, as well as a secure e-commerce system. The theory of CSP itself is also still the subject of active research, including work to increase its range of practical applicability (e.g., increasing the scale of the systems that can be tractably analyzed).},
  copyright = {Creative Commons Attribution-ShareAlike License},
  langid = {english},
  annotation = {Page Version ID: 1261864146},
  file = {/Users/dmz/Zotero/storage/LSCBR3ZW/Communicating_sequential_processes.html}
}

@online{CoqProof,
  title = {The {{Coq Proof Assistant}}},
  url = {https://coq.inria.fr/},
  urldate = {2025-02-20},
  file = {/Users/dmz/Zotero/storage/24NDDWQC/coq.inria.fr.html}
}

@online{CryptolLanguage2024,
  title = {Cryptol: {{The Language}} of {{Cryptography}}},
  shorttitle = {Cryptol},
  year = {2024},
  month = dec,
  url = {https://tools.galois.com/cryptol},
  urldate = {2025-02-20},
  langid = {english},
  file = {/Users/dmz/Zotero/storage/YDEDARLS/cryptol.html}
}

@online{EventBRodin,
  title = {Event-{{B}} and the {{Rodin Platform}}},
  url = {https://www.event-b.org/},
  urldate = {2025-02-20},
  file = {/Users/dmz/Zotero/storage/LHTPE52E/www.event-b.org.html}
}

@article{HoareCommunicatingSequential1978,
  title = {Communicating Sequential Processes},
  author = {Hoare, C. A. R.},
  year = {1978},
  month = aug,
  journal = {Commun. ACM},
  volume = {21},
  number = {8},
  pages = {666--677},
  issn = {0001-0782},
  doi = {10.1145/359576.359585},
  url = {https://dl.acm.org/doi/10.1145/359576.359585},
  urldate = {2025-02-20},
  abstract = {This paper suggests that input and output are basic primitives of programming and that parallel composition of communicating sequential processes is a fundamental program structuring method. When combined with a development of Dijkstra's guarded command, these concepts are surprisingly versatile. Their use is illustrated by sample solutions of a variety of a familiar programming exercises.},
  file = {/Users/dmz/Zotero/storage/2GN7MNFJ/Hoare - 1978 - Communicating sequential processes.pdf}
}

@online{Isabelle,
  title = {Isabelle},
  url = {https://isabelle.in.tum.de/},
  urldate = {2025-02-20},
  file = {/Users/dmz/Zotero/storage/Q2VWNHKD/isabelle.in.tum.de.html}
}

@book{JacksonEssenceSoftware2021,
  title = {The Essence of Software: Why Concepts Matter for Great Design},
  shorttitle = {The Essence of Software},
  author = {Jackson, Daniel},
  year = {2021},
  publisher = {Princeton University Press},
  address = {Princeton},
  abstract = {A revolutionary concept-based approach to thinking about, designing, and interacting with software As our dependence on technology increases, the design of software matters more than ever before. Why then is so much software flawed? Why hasn't there been a systematic and scalable way to create software that is easy to use, robust, and secure? Examining these issues in depth, The Essence of Software introduces a theory of software design that gives new answers to old questions. Daniel Jackson explains that a software system should be viewed as a collection of interacting concepts, breaking the functionality into manageable parts and providing a new framework for thinking about design. Through this radical and original perspective, Jackson lays out a practical and coherent path, accessible to anyone from strategist and marketer to UX designer, architect, or programmer{\'undefined}{$_4$}for making software that is empowering, dependable, and a delight to use. Jackson explores every aspect of concepts{\'undefined}{$_4$}what they are and aren{\'undefined}{$_9$}t, how to identify them, how to define them, and more{\'undefined}{$_4$}and offers prescriptive principles and practical tips that can be applied cost-effectively in a wide range of domains. He applies these ideas to contemporary software designs, drawing examples from leading software manufacturers such as Adobe, Apple, Dropbox, Facebook, Google, Microsoft, Twitter, and others. Jackson shows how concepts let designers preserve and reuse design knowledge, rather than starting from scratch in every project. An argument against the status quo and a guide to improvement for both working designers and novices to the field, The Essence of Software brings a fresh approach to software and its creation},
  isbn = {978-0-691-22538-8},
  langid = {english}
}

@inproceedings{JanotaEtAlCLOPSDSL2009,
  title = {{{CLOPS}}: {{A DSL}} for {{Command Line Options}}},
  shorttitle = {{{CLOPS}}},
  booktitle = {Domain-{{Specific Languages}}},
  author = {Janota, Mikol{\'a}{\v s} and Fairmichael, Fintan and Holub, Viliam and Grigore, Radu and Charles, Julien and Cochran, Dermot and Kiniry, Joseph R.},
  editor = {Taha, Walid Mohamed},
  year = {2009},
  pages = {187--210},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-03034-5_10},
  abstract = {Programmers often write custom parsers for the command line input of their programs. They do so, in part, because they believe that both their program's parameterization and their option formats are simple. But as the program evolves, so does the parameterization and the available options. Gradually, option parsing, data structure complexity, and maintenance of related program documentation becomes unwieldy. This article introduces a novel DSL called CLOPS that lets a programmer specify command line options and their complex inter-dependencies in a declarative fashion. The DSL is supported by a tool that generates the following features to support command line option processing: (1)~data structures to represent option values, (2)~a command line parser that performs validity checks, and (3)~command line documentation. We have exercised CLOPS by specifying the options of a small set of programs like ls, gzip, and svn which have complex command line interfaces. These examples are provided with the Open Source release of the CLOPS system.},
  isbn = {978-3-642-03034-5},
  langid = {english},
  keywords = {Command Line,Compression Level,Software Product Line,Validity Function,Validity Rule},
  file = {/Users/dmz/Zotero/storage/W46XLYEB/Janota et al. - 2009 - CLOPS A DSL for Command Line Options.pdf}
}

@online{LamportTLAHome,
  title = {The {{TLA}}+ {{Home Page}}},
  author = {Lamport, Leslie},
  url = {https://lamport.azurewebsites.net/tla/tla.html},
  urldate = {2025-02-20},
  file = {/Users/dmz/Zotero/storage/GFLD5XKU/tla.html}
}

@online{LeanProgramming,
  title = {The {{Lean Programming Language}} and {{Theorem Prover}}},
  url = {https://lean-lang.org/},
  urldate = {2025-02-20},
  file = {/Users/dmz/Zotero/storage/TNW994RA/lean-lang.org.html}
}

@article{MorrisLawsData1989,
  title = {Laws of Data Refinement},
  author = {Morris, Joseph M.},
  year = {1989},
  month = feb,
  journal = {Acta Informatica},
  volume = {26},
  number = {4},
  pages = {287--308},
  issn = {1432-0525},
  doi = {10.1007/BF00276019},
  url = {https://doi.org/10.1007/BF00276019},
  urldate = {2025-02-24},
  abstract = {A specification language typically contains sophisticated data types that are expensive or even impossible to implement. Their replacement with simpler or more efficiently implementable types during the programming process is called data refinement. We give a new formal definiton of data refinement and use it to derive some basic laws. The derived laws are constructive in that used in conjunction with the known laws of procedural refinement they allow us to calculate a new specification from a given one in which variables are to be replaced by other variables of a different type.},
  langid = {english},
  keywords = {Communication Network,Data Structure,Information System,Information Theory,Operating System},
  file = {/Users/dmz/Zotero/storage/RB8CGF74/Morris - 1989 - Laws of data refinement.pdf}
}

@article{NersonApplyingObjectoriented1992,
  title = {Applying Object-Oriented Analysis and Design},
  author = {Nerson, Jean-Marc},
  year = {1992},
  month = sep,
  journal = {Commun. ACM},
  volume = {35},
  number = {9},
  pages = {63--74},
  issn = {0001-0782},
  doi = {10.1145/130994.130997},
  url = {https://dl.acm.org/doi/10.1145/130994.130997},
  urldate = {2025-02-20},
  file = {/Users/dmz/Zotero/storage/CUE4ELAY/Nerson - 1992 - Applying object-oriented analysis and design.pdf}
}

@article{Notation2024,
  title = {Z Notation},
  year = {2024},
  month = jul,
  journal = {Wikipedia},
  url = {https://en.wikipedia.org/w/index.php?title=Z_notation&oldid=1232419052},
  urldate = {2025-02-20},
  abstract = {The Z notation  is a formal specification language used for describing and modelling computing systems. It is targeted at the clear specification of computer programs and computer-based systems in general.},
  copyright = {Creative Commons Attribution-ShareAlike License},
  langid = {english},
  annotation = {Page Version ID: 1232419052},
  file = {/Users/dmz/Zotero/storage/ENSSJU8N/Z_notation.html}
}

@online{OpenJML,
  title = {{{OpenJML}}},
  url = {https://www.openjml.org/},
  urldate = {2025-02-20},
  file = {/Users/dmz/Zotero/storage/8635QDX8/www.openjml.org.html}
}

@online{ProofOrientedProgramming,
  title = {F*: {{A Proof-Oriented Programming Language}}},
  url = {https://fstar-lang.org/},
  urldate = {2025-02-20}
}

@online{PrototypeVerification,
  title = {Prototype {{Verification System}} ({{PVS}})},
  url = {https://pvs.csl.sri.com/},
  urldate = {2025-02-20},
  file = {/Users/dmz/Zotero/storage/YVXTHMZW/pvs.csl.sri.com.html}
}

@online{ProVerifCryptographic,
  title = {{{ProVerif}}: {{Cryptographic}} Protocol Verifier in the Formal Model},
  url = {https://bblanche.gitlabpages.inria.fr/proverif/},
  urldate = {2025-02-20}
}

@online{RoboStar,
  title = {{{RoboStar}}},
  url = {https://robostar.cs.york.ac.uk/robotool/},
  urldate = {2025-02-20},
  file = {/Users/dmz/Zotero/storage/BPPX8MHP/robotool.html}
}

@book{RoeverEngelhardtDataRefinement2008,
  title = {Data {{Refinement}}: {{Model-Oriented Proof Methods}} and Their {{Comparison}}},
  shorttitle = {Data {{Refinement}}},
  author = {de Roever, Willem-Paul and Engelhardt, Kai},
  year = {2008},
  month = nov,
  edition = {1st},
  publisher = {Cambridge University Press},
  address = {USA},
  abstract = {The goal of this book is to provide a comprehensive and systematic introduction to the important and highly applicable method of data refinement and the simulation methods used for proving its correctness. The authors concentrate in the first part on the general principles needed to prove data refinement correct. They begin with an explanation of the fundamental notions, showing that data refinement proofs reduce to proving simulation. The topics of Hoare Logic and the Refinement Calculus are introduced and a general theory of simulations is developed and related to them. Accessibility and comprehension are emphasized in order to guide newcomers to the area. The book's second part contains a detailed survey of important methods in this field, such as VDM, and the methods due to Abadi \&amp; Lamport, Hehner, Lynch and Reynolds, Back's refinement calculus and Z. All these methods are carefully analysed, and shown to be either imcomplete, with counterexamples to their application, or to be always applicable whenever data refinement holds. This is shown by proving, for the first time, that all these methods can be described and analyzed in terms of two simple notions: forward and backward simulation. The book is self-contained, going from advanced undergraduate level and taking the reader to the state of the art in methods for proving simulation.},
  isbn = {978-0-521-10350-3}
}

@online{SymbolicAnalysis,
  title = {Symbolic {{Analysis Laboratory}}},
  url = {https://sal.csl.sri.com/},
  urldate = {2025-02-20},
  file = {/Users/dmz/Zotero/storage/Y6WEAALY/sal.csl.sri.com.html}
}

@online{TamarinProver,
  title = {Tamarin {{Prover}}},
  url = {https://tamarin-prover.com/},
  urldate = {2025-02-20}
}

@online{TheMathWorksInc.MATLAB,
  title = {{{MATLAB}}},
  author = {{The MathWorks, Inc.}},
  url = {https://www.mathworks.com/products/matlab.html},
  urldate = {2025-02-20},
  abstract = {The official home of MATLAB software. MATLAB is the easiest and most productive software environment for engineers and scientists. Try, buy, and learn MATLAB.},
  langid = {english},
  file = {/Users/dmz/Zotero/storage/WFUV5A6N/matlab.html}
}

@online{TheMathWorksInc.SimulinkSimulation,
  title = {Simulink - {{Simulation}} and {{Model-Based Design}}},
  author = {{The MathWorks, Inc.}},
  url = {https://www.mathworks.com/products/simulink.html},
  urldate = {2025-02-20},
  abstract = {Simulink is a block diagram environment for Model-Based Design. It supports simulation, automatic code generation, and continuous testing of embedded systems.},
  langid = {english},
  file = {/Users/dmz/Zotero/storage/H7C5RR46/simulink.html}
}

@online{UnifiedModeling,
  title = {The {{Unified Modeling Language}}},
  url = {https://www.uml.org/},
  urldate = {2025-02-20},
  file = {/Users/dmz/Zotero/storage/EBBVBCH8/www.uml.org.html}
}

@article{ViennaDevelopment2024,
  title = {Vienna {{Development Method}}},
  year = {2024},
  month = jul,
  journal = {Wikipedia},
  url = {https://en.wikipedia.org/w/index.php?title=Vienna_Development_Method&oldid=1236341340},
  urldate = {2025-02-20},
  abstract = {The Vienna Development Method (VDM) is one of the longest-established formal methods for the development of computer-based systems. Originating in work done at the IBM Laboratory Vienna in the 1970s, it has grown to include a group of techniques and tools based on a formal specification language---the VDM Specification Language (VDM-SL). It has an extended form, VDM++, which supports the modeling of object-oriented and concurrent systems. Support for VDM includes commercial and academic tools for analyzing models, including support for testing and proving properties of models and generating program code from validated VDM models. There is a history of industrial usage of VDM and its tools and a growing body of research in the formalism has led to notable contributions to the engineering of critical systems, compilers, concurrent systems and in logic for computer science.},
  copyright = {Creative Commons Attribution-ShareAlike License},
  langid = {english},
  annotation = {Page Version ID: 1236341340},
  file = {/Users/dmz/Zotero/storage/IA8LUBLZ/Vienna_Development_Method.html}
}

@online{WelcomeWorld,
  title = {Welcome to the World of {{Statecharts}}},
  url = {https://statecharts.dev/},
  urldate = {2025-02-20},
  abstract = {The world of statecharts describes what statecharts are, their benefits and drawbacks, how they differ from state machines, and practical examples on how to use them.},
  langid = {american},
  file = {/Users/dmz/Zotero/storage/894VEUEZ/statecharts.dev.html}
}
