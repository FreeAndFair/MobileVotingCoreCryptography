#!/usr/bin/env python3

# Prune Tamarin Exists Trace
#
# This script prunes Tamarin proof scripts for exists-trace
# lemmas, leaving only one proof path that leads to one
# satisfying execution trace. It is based on a script that
# was generated by GPT-5 after a _lot_ of trial and error.
#
# Note that it works only on straightforward Tamarin
# executability proofs (using "simplify" and "solve", but no
# induction, and possibly only those that use "simplify" one
# time). Using it on other proof scripts will result in
# garbage. At some point I will figure out how to make it
# more robust; for now, it's here because I found it useful
# for some limited purposes in generating some of the
# proof scripts below the `models/cryptography/tamarin`
# directory of the repository.
#
# For command line usage information, run the script with no
# command line arguments.
#
# Daniel M. Zimmerman, August 2025
# Copyright (C) 2025 Free & Fair

from __future__ import annotations

import argparse
import re
import sys
from dataclasses import dataclass, field
from typing import List, Literal, Optional, Dict

# Tamarin keywords that indicate the beginnings of proof blocks,
# and a function to find them in lines.
Head = Literal["solve", "case", "qed", "next", "other"]

# Determine the Tamarin keyword on a frame boundary.
def head_of(line: str) -> Head:
    s = line.lstrip()
    if s.startswith("simplify"): return "simplify"
    if s.startswith("solve("):   return "solve"
    if s.startswith("case "):    return "case"
    if s.startswith("qed"):      return "qed"
    if s.startswith("next"):     return "next"
    return "other"

# Tamarin keywords that indicate a lemma has been solved, and
# functions to find them in lines.
DEFAULT_SUCCESS_PATTERNS = [
    r"^\s*SOLVED\b"
]

def compile_success(patterns: List[str]) -> List[re.Pattern]:
    return [re.compile(p, re.IGNORECASE) for p in patterns]

def is_success(line: str, success_res: List[re.Pattern]) -> bool:
    return any(r.search(line) for r in success_res)

# Data structures for tracking proof frames, cases, etc.
@dataclass
class Frame:
    open_idx: int
    close_idx: Optional[int] = None
    keep: bool = False
    parent: Optional["Frame"] = None
    children: List["Frame"] = field(default_factory=list)
    case_depth_start: int = 0  # The number of active cases when this frame opened.

@dataclass
class CaseInfo:
    open_idx: int
    keep: bool = False

@dataclass
class ParseResult:
    roots: List[Frame]
    case_keep: Dict[int, bool]

# "Parse" the input file, looking for Tamarin proof structure tokens.
def parse(lines: List[str], success_res: List[re.Pattern], first_success_only: bool) -> ParseResult:
    """
    Semantics:
      - 'solve(' opens a frame (pushed on frame_stack).
      - 'case' pushes a case marker (separate stack).
      - 'next' pops one case marker.
      - 'qed' pops exactly one frame (solve or simplify); if a solve closes, all
        cases opened under it are implicitly closed.
      - a 'success' line marks all open frames AND active cases as kept;
        If first_success_only=True, only the first encountered success is kept.
    """
    roots: List[Frame] = []
    frame_stack: List[Frame] = []
    case_stack: List[CaseInfo] = []
    all_cases: Dict[int, CaseInfo] = {}
    first_success_seen = False

    def push_frame(i: int):
        parent = frame_stack[-1] if frame_stack else None
        fr = Frame(open_idx=i, parent=parent, case_depth_start=len(case_stack))
        (parent.children if parent else roots).append(fr)
        frame_stack.append(fr)

    for i, ln in enumerate(lines):
        # Mark success (possibly only the first).
        if is_success(ln, success_res) and (not first_success_only or not first_success_seen):
            for fr in frame_stack:
                fr.keep = True
            for cs in case_stack:
                cs.keep = True
            first_success_seen = True

        h = head_of(ln)
        if h == "solve":
            push_frame(i)
        elif h == "case":
            cs = CaseInfo(open_idx=i, keep=False)
            case_stack.append(cs)
            all_cases[i] = cs
        elif h == "qed":
            if frame_stack:
                fr = frame_stack.pop()
                fr.close_idx = i
                while len(case_stack) > fr.case_depth_start:
                    case_stack.pop()
        elif h == "next":
            if case_stack:
                case_stack.pop()

    return ParseResult(roots=roots, case_keep={k: v.keep for k, v in all_cases.items()})

# Return whether a frame is marked as "kept".
def has_kept_desc(fr: Frame) -> bool:
    return fr.keep or any(has_kept_desc(c) for c in fr.children)

# Emit the pruned proof script.
def emit(lines: List[str], parsed: ParseResult) -> List[str]:
    out: List[str] = []
    roots = parsed.roots
    case_keep_map = parsed.case_keep

    # Build open-index map for frames
    opens: Dict[int, List[Frame]] = {}
    def collect(fr: Frame):
        opens.setdefault(fr.open_idx, []).append(fr)
        for ch in fr.children:
            collect(ch)
    for r in roots:
        collect(r)

    frame_stack: List[Frame] = []
    case_stack: List[CaseInfo] = []

    at_beginning = True
    last_output_qed = False
    for i, ln in enumerate(lines):
        h = head_of(ln)

        # Push frames opening here.
        for fr in opens.get(i, []):
            frame_stack.append(fr)

        # Pre-handle case push/pop so case context is correct for this line.
        if h == "case":
            case_stack.append(CaseInfo(open_idx=i, keep=case_keep_map.get(i, False)))
        elif h == "next":
            if case_stack:
                case_stack.pop()

        # Compute context flags.
        top = frame_stack[-1] if frame_stack else None
        on_kept_path = bool(top and has_kept_desc(top))
        in_kept_solve = any(has_kept_desc(f) for f in frame_stack)
        all_cases_kept = all(c.keep for c in case_stack)

        # Determine output.
        if h == "next":
            pass  # Never output "next".
        elif h == "simplify":
            # output "simplify" if it's at the beginning or on the kept path,
            # but never right after "qed"
            if (not last_output_qed) and (on_kept_path or at_beginning):
                out.append(ln)
        elif h == "case":
            if on_kept_path and case_keep_map.get(i, False):
                out.append(ln)
        elif h == "solve":
            if on_kept_path:
                out.append(ln)
        elif h == "qed":
            # Output 'qed' only if the frame being closed is kept.
            closing = frame_stack[-1] if frame_stack else None
            if closing and has_kept_desc(closing):
                out.append(ln)
                last_output_qed = True
            # Pop the frame and clear cases if a solve closes.
            if frame_stack:
                fr = frame_stack.pop()
                while case_stack and len(case_stack) > fr.case_depth_start:
                    case_stack.pop()
            continue
        else:
            if in_kept_solve and all_cases_kept:
                out.append(ln)

        at_beginning = False

    return out

# Main function (command line processing).
def main(args):
    with open(args.proof_script, "r", encoding="utf-8", errors="replace") as f:
        lines = [ln.rstrip("\n") for ln in f]

    success_res = compile_success(DEFAULT_SUCCESS_PATTERNS + args.success)
    parsed = parse(lines, success_res, first_success_only=(not args.all_successes))
    out_lines = emit(lines, parsed)

    if args.debug:
        success_lines = sum(1 for ln in lines if is_success(ln, success_res))
        print(f"[debug] success_lines={success_lines}", file=sys.stderr)
        print(f"[debug] output_lines={len(out_lines)}", file=sys.stderr)

    text = "\n".join(out_lines)
    if args.output:
        with open(args.output, "w", encoding="utf-8") as g:
            g.write(text + ("\n" if out_lines and not out_lines[-1].endswith('\n') else ""))
    else:
        print(text)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Prune Tamarin exists-trace proof script to a single execution path.")
    parser.add_argument("proof_script")
    parser.add_argument("-o", "--output", help="Output file (default: stdout)")
    parser.add_argument("--success", action="append", default=[], help="Additional success regular expression (repeatable)")
    parser.add_argument("--all-successes", action="store_true",
                    help="Keep all success paths (default: keep only the first success path).")
    parser.add_argument("--debug", action="store_true", help="Output debugging information to stderr")
    main(parser.parse_args())
