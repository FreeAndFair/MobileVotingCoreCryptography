dnl
dnl This is the m4 input file for the Ballot Submission Subprotocol.
dnl If the STANDALONE macro is defined, this file generates a standalone
dnl version of the subprotocol; otherwise, it generates a Tamarin code
dnl snippet suitable for inclusion in a Tamarin file composing multiple
dnl subprotocols.
dnl
dnl If the BALLOT_SUBMISSION_MOCKS macro is defined (which is always the case
dnl when STANDALONE is defined), the Tamarin code snippet will include
dnl mock rules that simulate required actions of other subprotocols by
dnl establishing suitable linear/persistent/action facts.
dnl
dnl @author Daniel M. Zimmerman
dnl @copyright Free & Fair 2025
dnl @version 0.1
dnl
dnl We change the m4 quote characters to <! and !>, so that they don't
dnl interfere with Tamarin's quote characters or any comments we might
dnl want to write. The incantation below makes that change, and ensures
dnl that we don't try to change them if we've already done so (e.g.,
dnl when including this file in a composition).
dnl
ifdef(<!QUOTE_CHANGED!>,<!!>,<!changequote(`<!', `!>')!>)dnl
dnl
ifdef(<!STANDALONE!>,<!/*
  Ballot Submission Subprotocol

  This subprotocol covers ballot submission (the posting of a
  ballot to the bulletin board before it is either cast or checked).
  It uses a secure channel abstraction, where adversaries are capable
  of both intercepting and injecting messages into channels, to model
  secure connections such as TLS, but also uses explicit digital
  signatures for content that needs to be posted to the public
  bulletin board.

  @author Daniel M. Zimmerman
  @copyright Free & Fair 2025
  @version 0.1
 */

theory ballot_submission

begin

define(<!USE_UNIQUE!>)dnl
define(<!USE_EUFCMA_SIGNING!>)dnl
define(<!USE_ABSTRACTED_NAOR_YUNG!>)dnl
define(<!USE_PSEUDONYM!>)dnl
define(<!USE_EQUALITY!>)dnl
define(<!USE_INEQUALITY!>)dnl
include(common/primitives.m4.inc)
define(<!USE_SECURE_CHANNELS!>)dnl
define(<!USE_SECURE_CHANNELS_INJECTION!>)dnl
define(<!USE_SECURE_CHANNELS_INTERCEPTION!>)dnl
include(common/channels.m4.inc)
include(common/bulletinboard.m4.inc)

!>)dnl
dnl If STANDALONE is defined, all mocks are always required
ifdef(<!STANDALONE!>,<!define(BALLOT_SUBMISSION_MOCKS)!>)dnl
dnl
ifdef(<!BALLOT_SUBMISSION_MOCKS!>,<!
/*
  The initial counters for ballot styles and voters are %1, and
  the election configuration is just a fresh variable.
 */
rule BallotSubmission_Mock_EC_And_Initial_Counters [role="Mock"]:
    [ Fr(~ec) ]
  --[ Unique(<'EC_And_Initial_Counters', ~ec>),
      ElectionConfiguration_Trace(~ec) ]->
    [ BallotStyleCount(~ec, %1),
      VoterCount(~ec, %1) ]

/*
  Mock ballot styles into the environment. We simply
  generate an arbitrary number of persistent facts with ballot style
  identifiers for later use.
 */
rule BallotSubmission_Mock_BallotStyle [role="Mock"]:
    [ BallotStyleCount(~ec, %i),
      Fr(~ballot_style) ]
  --[ BallotStyle_Trace(~ec, ~ballot_style, %i) ]->
    [ !BallotStyle(~ec, ~ballot_style, %i),
      BallotStyleCount(~ec, %i %+ %1) ]

/*
  Mock a voter registration database into the environment (for a voter
  that is eligible for this election). Voter IDs are Tamarin public
  variables (because we want the adversary to be able to attempt
  masquerading as a voter), that are distinguished by persistent facts
  associating them with eligibility information.
 */
rule BallotSubmission_Mock_VoterRegistration_Eligible [role="Mock"]:
    [ VoterCount(~ec, %i),
      !BallotStyle(~ec, ~ballot_style, %unused) ]
  --[ Unique(<'VoterRegistration', ~ec, $V>),
      EligibleVoter_Trace(~ec, $V, ~ballot_style, %i) ]->
    [ !EligibleVoter(~ec, $V, ~ballot_style, %i),
      VoterCount(~ec, %i %+ %1) ]

/*
  Stop registering voters and ballot styles, then broadcast the
  election configuration, create the bulletin board, and start
  mocking voter authentications.

  Note that we mock an election private key here; that's so
  we have a valid election public key, for our abstracted
  equational theory of ballot encryption to be able to work. In
  reality, there is no "election private key" in this sense, as
  the election public key is generated by the trustees using
  a threshold sharing scheme.
 */
rule BallotSubmission_Mock_Finalize_Election_Setup [role="Mock"]:
    [ !BallotStyle(~ec, ~bs_unused, %idx_bs_unused),
      !EligibleVoter(~ec, $EV, ~ev_bs_unused, %idx_ev_unused),
      BallotStyleCount(~ec, %next_idx_bs_unused),
      VoterCount(~ec, %next_idx_v_unused),
      Fr(~k) /* mock election private key */ ]
  --[ Unique(<'FinalizeElectionSetup', ~ec>),
      Finalize_Election_Setup_Trace(~ec) ]->
    [ !ElectionConfiguration(~ec),
      !ElectionPublicKey(~ec, pk(~k)),
      AuthCount(~ec, %1),
      BB_Create_Request(~ec, ~ec),
      Out(~ec) ]

/*
  Mock a voter authentication. This creates the persistent and
  linear facts that authorize a voter with a particular public
  key to vote a ballot of a particular ballot style and prompt
  the VA to have the voter fill in their ballot.

  Note that this can happen continuously, mocking the fact that
  the voter authentication protocol runs concurrently (for other
  voters) with theballot submission protocol. Note also that this
  can (rightly) result in a particular VA session having its
  votes rejected because the voter public key it was using was
  superceded by a subsequent authentication.
 */
rule BallotSubmission_Mock_Voter_Authentication [role="Mock"]:
  let pk_voter = pk(~sk_voter) in
    [ AuthCount(~ec, %i),
      !BallotStyle(~ec, ~bs, %idx_bs),
      !EligibleVoter(~ec, $V, ~bs, %idx_ev),
      Fr(~sk_voter),
      Fr(~va_id) ]
  --[ Unique(<'VoterAuth', %i>),
      HonestSignatureKey(pk_voter),
      Voter_Authentication_Trace(~ec, ~va_id, $V, ~sk_voter, %i),
      DBB_Voter_Authorized_Trace(~ec, pseudonym($V), pk_voter, ~bs, %i) ]->
    [ !DBB_Voter_Authorized(~ec, pseudonym($V), pk_voter, ~bs, %i),
      !VA_Eligible_Voter(~ec, ~va_id, pseudonym($V), ~sk_voter, ~bs),
      VA_State_PresentBallot(~ec, ~va_id, $V, ~sk_voter),
      AuthCount(~ec, %i %+ %1) ]

/*
  A rule that has BB_Terminate_Request on its right-hand side, so
  that we don't get a well-formedness warning when we don't use it.
  Note that we are requesting to terminate a bulletin board that
  doesn't actually exist, so this should have no real effect on
  anything.
 */
rule BallotSubmission_Mock_BBTerminate [role="Mock"]:
    []
  --[ Unique('BallotSubmission_Mock_BB_Terminate') ]->
    [ BB_Terminate_Request('fake_bbid', %1) ]

/*
  This rule initializes the "clock" (really, just a monotonic counter
  used in posting messages to the bulletin board) for the DBB.
 */
rule BallotSubmsision_Mock_DBBTimestamp [role="Mock"]:
    []
  --[]->
    [ DBB_Clock(%1) ]

!>)
dnl
macros:
  /*
    Message types. The ones that include an "ec_hash" will actually use
    the election configuration, not its hash, because it is public
    information and Tamarin doesn't care if we hash it or not. The ones
    that include "cryptograms" will actually only include a single
    cryptogram (with two ciphertext components and a proof), because we
    don't really care at this level about specific contests, and going
    from one cryptogram to a list is easily generalizable.
   */
  Msg_VA_Submit_Ballot(ec_hash, pseudonym, pk_voter, ballot_style, cryptograms) = <'VA_Submit_Ballot', ec_hash, pseudonym, pk_voter, ballot_style, cryptograms>,
  Msg_DBB_Ballot_Tracker(ec_hash, tracker) = <'DBB_Ballot_Tracker', ec_hash, tracker>,
  Msg_DBB_Ballot_Error(ec_hash, error) = <'DBB_Ballot_Error', error>,

  /*
    Bulletin board entries. Note that we don't explicitly include the hash
    of the previous bulletin board entry in these, because it is included
    automatically by the bulletin board during the entry append process.
    We also don't include the DBB signature, because we are assuming in
    Tamarin that only the DBB can append messages to the bulletin board
    (that is, only DBB actions create bulletin board entries).
   */
  BBEntry_Ballot_Submission(ec_hash, timestamp, ballot_msg) = <'BBEntry_Ballot_Submission', ec_hash, timestamp, ballot_msg>
dnl
dnl Include the rules.
dnl

include(subprotocols/includes/ballot_submission_rules.spthy.inc)dnl

dnl
dnl Include the lemmas.
dnl

include(subprotocols/includes/ballot_submission_lemmas.spthy.inc)dnl

dnl
ifdef(<!STANDALONE!>,<!
end
!>)dnl
