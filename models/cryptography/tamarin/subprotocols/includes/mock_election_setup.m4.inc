dnl
dnl This is the m4 input file for mocking election setup: the creation
dnl of an election, registered voters, and ballot styles, the creation
dnl of a bulletin board, and the mocking of election keys.
dnl
dnl @author Daniel M. Zimmerman
dnl @copyright Free & Fair 2025
dnl @version 0.1
dnl

/*
  The initial counters for ballot styles and voters are %1, and
  the election configuration is just a fresh variable.
 */
rule Mock_EC_And_Initial_Counters [role="Mock"]:
    [ Fr(~ec) ]
  --[ Unique(<'EC_And_Initial_Counters', ~ec>),
      ElectionConfiguration_Trace(~ec) ]->
    [ BallotStyleCount(~ec, %1),
      VoterCount(~ec, %1) ]

/*
  Mock ballot styles into the environment. We simply
  generate an arbitrary number of persistent facts with ballot style
  identifiers for later use.
 */
rule Mock_BallotStyle [role="Mock"]:
    [ BallotStyleCount(~ec, %i),
      Fr(~ballot_style) ]
  --[ BallotStyle_Trace(~ec, ~ballot_style, %i) ]->
    [ !BallotStyle(~ec, ~ballot_style, %i),
      BallotStyleCount(~ec, %i %+ %1) ]

/*
  Mock a voter registration database into the environment (for a voter
  that is eligible for this election). Voter IDs are Tamarin public
  variables (because we want the adversary to be able to attempt
  masquerading as a voter), that are distinguished by persistent facts
  associating them with eligibility information.
 */
rule Mock_VoterRegistration_Eligible [role="Mock"]:
    [ VoterCount(~ec, %i),
      !BallotStyle(~ec, ~ballot_style, %unused) ]
  --[ Unique(<'VoterRegistration', ~ec, $V>),
      EligibleVoter_Trace(~ec, $V, ~ballot_style, %i) ]->
    [ !EligibleVoter(~ec, $V, ~ballot_style, %i),
      VoterCount(~ec, %i %+ %1) ]

/*
  Stop registering voters and ballot styles, then broadcast the
  election configuration, create the bulletin board, and start
  mocking voter authentications (if necessary).

  Note that we mock an election secret key here; that's so
  we have a valid election public key, for our abstracted
  equational theory of ballot encryption to be able to work. In
  reality, there is no "election secret key" in this sense, as
  the election public key is generated by the trustees using
  a threshold sharing scheme.
 */
rule Mock_Finalize_Election_Setup [role="Mock"]:
    [ !BallotStyle(~ec, ~bs_unused, %idx_bs_unused),
      !EligibleVoter(~ec, $EV, ~ev_bs_unused, %idx_ev_unused),
      BallotStyleCount(~ec, %next_idx_bs_unused),
      VoterCount(~ec, %next_idx_v_unused),
      Fr(~sk_eas), /* mock EAS private key */
      Fr(~sk_election) /* mock election private key */ ]
  --[ Unique(<'FinalizeElectionSetup', ~ec>),
      HonestSignatureKey(pk(~sk_eas)),
      Finalize_Election_Setup_Trace(~ec) ]->
    [ !ElectionConfiguration(~ec),
      !ElectionPublicKey(~ec, pk(~sk_election)),
      !ElectionSecretKey(~ec, ~sk_election),
      !EASPublicKey(~ec, pk(~sk_eas)),
      !EASSecretKey(~ec, ~sk_eas),
      AuthCount(~ec, %1),
      BB_Create_Request(~ec, ~ec),
      DBB_State_ReceiveAuthorizeVoter(~ec, %1),
      Out(~ec) ]
