/* Lemmas for trustee decryption subprotocol. */

/* Sources Lemma */

/*
  This is a translation of the sources lemma generated by Tamarin's
  --auto-sources. It works, but takes a lot of precomputation
  memory, and it's not clear how well it would scale to higher
  numbers of trustees.

  Tamarin can verify this lemma automatically, but it takes a long time
  (over 6 hours for 3 trustees with a threshold of 2) and results in a
  very long proof script (over 300000 steps, over 180MB in size) that,
  even when included, takes considerable time to verify. We are therefore
  not including the proof script at this time.
 */
define(<!PROOF_SCRIPT!>, ifdef(<!INCLUDE_PROOF_SCRIPTS!>, ifdef(<!STANDALONE!>, <!subprotocols/includes/proofs/Sources_TrusteeDecryption_<!!>TRUSTEE_COUNT<!!>_<!!>TRUSTEE_THRESHOLD<!!>.spthy.inc!>, <!/tmp/NOPROOFSCRIPT!>), <!/tmp/NOPROOFSCRIPT!>))dnl
syscmd(cat PROOF_SCRIPT > /dev/null 2>&1)dnl
lemma ifelse(sysval, <!0!>, <!ProofScript!>, <!NoProofScript!>)_Sources_TrusteeDecryption [sources]:
  "
      (All x m #i.
            IN_BALLOTSET_C1_TERM(m, x)@i
        ==>
            (
                (Ex #j.
                  (
                      KU(x)@j
                    &
                      #j < #i
                  )
                )
              |
                (Ex #j.
                  (
                      OUT_BALLOTSET_C1_TERM(m)@j
                    &
                      #j < #i
                  )
                )
            )
      )
    &
      (All x m #i.
            IN_BALLOTSET_C2_TERM(m, x)@i
        ==>
            (
                (Ex #j.
                  (
                      KU(x)@j
                    &
                      #j < #i
                  )
                )
              |
                (Ex #j.
                  (
                      OUT_BALLOTSET_C2_TERM(m)@j
                    &
                      #j < #i
                  )
                )
            )
      )
  "
dnl Include the proof script, if one exists.
sinclude(PROOF_SCRIPT)dnl


/* Protocol Safety Lemmas */

/*
  This lemma states that the only valid trustee names are the
  <!!>TRUSTEE_COUNT<!!> that start with 'Trustee' (this includes
  'Trustee0' for this subprotocol).
 */
lemma Safety_TrusteeDecryption_Valid_Trustee_Names [reuse]:
  "
    All tn pk_sign pk_encrypt #i.
          TAS_Trustee_Trace(tn, pk_sign, pk_encrypt)@i
      ==>
forloop(<!TN!>, <!0!>, TRUSTEE_COUNT, <!            tn = 'Trustee<!!>TN<!!>'<!!>ifelse(eval(TN < TRUSTEE_COUNT), eval(1), <!
          |
!>)!>)
  "

/*
  This lemma states that each trustee name only has one associated
  identity.
 */
lemma Safety_TrusteeDecryption_Only_One_Identity_Per_Trustee [reuse]:
  "
    All tr sk1 sk2 pk1 pk2 #i1 #i2.
            TAS_Trustee_Trace(tr, sk1, pk1)@i1
          &
            TAS_Trustee_Trace(tr, sk2, pk2)@i2
      ==>
          sk1 = sk2 & pk1 = pk2
  "

/*
  This lemma states that all trustees and the TAS agree on the election
  setup (it is redundant with a lemma from the election setup protocol
  but is provided here for Tamarin's reuse).
 */
lemma Safety_TrusteeDecryption_UniqueElectionSetup [reuse]:
  "
    All tr es1 es2 es3 #i1 #i2 #j.
          TAS_ElectionSetup_Complete_Trace(es1)@i1
        &
          TAS_ElectionSetup_Complete_Trace(es2)@i2
        &
          Trustee_ElectionSetup_Trace(tr, es3)@j
      ==>
          es1 = es2 & es1 = es3 & es2 = es3
  "

/*
  This lemma states that all TAS BB messages, except the root message,
  come from one of the <!!>TRUSTEE_COUNT<!!> trustees (or are injected
  with their signature).
 */
lemma Safety_TrusteeDecryption_TAS_BB_Message_Sources [reuse]:
  "
    All sd sl msg sig %idx #i.
            TAS_BBEntry_Trace(sd, sl, msg, sig, %idx)@i
      ==>
forloop(<!TN!>, <!0!>, TRUSTEE_COUNT, <!            sd = 'Trustee<!!>TN<!!>'<!!>ifelse(eval(TN < TRUSTEE_COUNT), eval(1), <!
          |
!>)!>)
  "

/*
  This lemma states that no two TAS trustee board messages have the
  same index.
 */
lemma Safety_TrusteeDecryption_TAS_BB_No_Duplicate_Indices [reuse]:
  "
    All tr1 tr2 mt1 mt2 msg1 msg2 sig1 sig2 %idx #i1 #i2.
            TAS_BBEntry_Trace(tr1, mt1, msg1, sig1, %idx)@i1
          &
            TAS_BBEntry_Trace(tr2, mt2, msg2, sig2, %idx)@i2
      ==>
          tr1 = tr2 & mt1 = mt2 & msg1 = msg2 & sig1 = sig2 & #i1 = #i2
  "

/*
  This lemma states that all BB messages on the TAS trustee board
  have distinct event times.
 */
lemma Safety_TrusteeDecryption_TAS_BB_Distinct_Timestamps [reuse]:
  "
    All sd1 sd2 sl1 sl2 msg1 msg2 sig1 sig2 %idx1 %idx2 #i1 #i2.
            TAS_BBEntry_Trace(sd1, sl1, msg1, sig1, %idx1)@i1
          &
            TAS_BBEntry_Trace(sd2, sl2, msg2, sig2, %idx2)@i2
          &
            not (%idx1 = %idx2)
          &
            #i1 = #i2
      ==>
          F
  "

/*
  This lemma states that every entry on the TAS trustee board, other
  than the root message, is from a registered trustee and has a
  valid signature.
 */
lemma Safety_TrusteeDecryption_TAS_BB_Message_Validity [reuse]:
  "
    All tr mt msg sig %idx #i.
            TAS_BBEntry_Trace(tr, mt, msg, sig, %idx)@i
      ==>
          (Ex pk_sign pk_encrypt param sk #j #k.
              TAS_Trustee_Trace(tr, pk_sign, pk_encrypt)@j
            &
              HonestSignatureKey(pk_sign)@k
            &
              pk(sk) = pk_sign
            &
              sig = sign(msg, param, sk)
          )
  "

/*
  This lemma states that there is at most one message in each slot
  from each trustee on the TAS trustee board, unless one was injected.
 */
lemma Safety_TrusteeDecryption_TAS_BB_No_Duplicate_Slots [reuse]:
  "
    All sd sl msg1 msg2 sig1 sig2 %idx1 %idx2 #i1 #i2.
            TAS_BBEntry_Trace(sd, sl, msg1, sig1, %idx1)@i1
          &
            TAS_BBEntry_Trace(sd, sl, msg2, sig2, %idx2)@i2
      ==>
            (msg1 = msg2 & sig1 = sig2 & %idx1 = %idx2 & #i1 = #i2)
          |
            (Ex #j. InjectTrusteeMsg(sd, msg1, sig1)@j)
          |
            (Ex #j. InjectTrusteeMsg(sd, msg2, sig2)@j)
  "

/*
  This lemma states that all trustee BB messages, except the root message,
  come from one of the <!!>TRUSTEE_COUNT<!!> trustees - including trustee
  0 - or are injected with their signature.
 */
lemma Safety_TrusteeDecryption_Trustee_BBs_Message_Sources [reuse]:
  "
    All tr sd sl msg sig %idx #i.
            Trustee_BBEntry_Trace(tr, sd, sl, msg, sig, %idx)@i
      ==>
forloop(<!TN!>, <!0!>, TRUSTEE_COUNT, <!            sd = 'Trustee<!!>TN<!!>'<!!>ifelse(eval(TN < TRUSTEE_COUNT), eval(1), <!
          |
!>)!>)
  "

/*
  This lemma states that each trustee's local trustee board
  follows the TAS trustee board; i.e., it has exactly the same
  sequence of messages up until the trustee's local board ends,
  which may be before the TAS trustee board ends depending on
  the legality of the message sequence on the TAS trustee board
  and whether the local trustee board has caught up.
 */
lemma Safety_TrusteeDecryption_Trustee_BBs_Follow_TAS [reuse]:
  "
    All tr sd1 sd2 sl1 sl2 msg1 msg2 sig1 sig2 %idx #i1 #i2.
            Trustee_BBEntry_Trace(tr, sd1, sl1, msg1, sig1, %idx)@i1
          &
            TAS_BBEntry_Trace(sd2, sl2, msg2, sig2, %idx)@i2
      ==>
          sd1 = sd2 & sl1 = sl2 & msg1 = msg2 & sig1 = sig2
  "

/*
  This lemma states that all the local trustee boards have the same
  message sequence, as far as they all go (it is effectively another
  way of stating that all the trustee BBs follow the TAS BB),
  but it may help Tamarin to state it separately.
 */
lemma Safety_TrusteeDecryption_Trustee_BBs_Match [reuse]:
  "
    All tr1 tr2 sd1 sd2 sl1 sl2 msg1 msg2 sig1 sig2 %idx #i1 #i2.
            Trustee_BBEntry_Trace(tr1, sd1, sl1, msg1, sig1, %idx)@i1
          &
            Trustee_BBEntry_Trace(tr2, sd2, sl2, msg2, sig2, %idx)@i2
      ==>
          sd1 = sd2 & sl1 = sl2 & msg1 = msg2 & sig1 = sig2
  "

/*
  This lemma states that there is at most one message in each slot
  from each trustee on each trustee's local board.
 */
lemma Safety_TrusteeDecryption_Trustee_BBs_No_Duplicate_Slots [reuse]:
  "
    All tr sd sl msg1 msg2 sig1 sig2 %idx1 %idx2 #i1 #i2.
            Trustee_BBEntry_Trace(tr, sd, sl, msg1, sig1, %idx1)@i1
          &
            Trustee_BBEntry_Trace(tr, sd, sl, msg2, sig2, %idx2)@i2
      ==>
          msg1 = msg2 & sig1 = sig2 & %idx1 = %idx2 & #i1 = #i2
  "

/*
  This lemma states that all BB messages on local trustee boards
  have distinct event times.
 */
lemma Safety_TrusteeDecryption_Trustee_BBs_Distinct_Timestamps [reuse]:
  "
    All tr sd1 sd2 sl1 sl2 msg1 msg2 sig1 sig2 %idx1 %idx2 #i1 #i2.
            Trustee_BBEntry_Trace(tr, sd1, sl1, msg1, sig1, %idx1)@i1
          &
            Trustee_BBEntry_Trace(tr, sd2, sl2, msg2, sig2, %idx2)@i2
          &
            not (%idx1 = %idx2)
          &
            #i1 = #i2
      ==>
          F
  "

/*
  Protocol Executability Lemmas

  Note that these are verified without reusing any lemmas that Tamarin
  cannot verify automatically or that do not have proof scripts, so
  they are all valid despite some of the safety lemmas not having been
  verified.
*/

/*
  This lemma states that it is possible to reach a state where the
  initial set of ballots has been posted.
 */
lemma Executability_TrusteeDecryption_Ballots_Posted:
  exists-trace
  "
    Ex c b #i. TAS_TrusteeDecryption_Init_Trace(c, b)@i
  "

/*
  This lemma states that it is possible to reach a state where a single
  trustee has partially decrypted the ballots.

  Tamarin can verify this lemma automatically, but it takes a decent
  amount of time. If a proof script is available for <!!>TRUSTEE_COUNT<!!> trustees
  with a threshold of <!!>TRUSTEE_THRESHOLD<!!>, it can be included
  below.
 */
define(<!PROOF_SCRIPT!>, ifdef(<!INCLUDE_PROOF_SCRIPTS!>, <!subprotocols/includes/proofs/TrusteeDecryption_One_Partial_Decryption_<!!>TRUSTEE_COUNT<!!>_<!!>TRUSTEE_THRESHOLD<!!>.spthy.inc!>, <!/tmp/NOPROOFSCRIPT!>))dnl
syscmd(cat PROOF_SCRIPT > /dev/null 2>&1)dnl
lemma ifelse(sysval, <!0!>, <!ProofScript!>, <!NoProofScript!>)_Executability_TrusteeDecryption_One_Partial_Decryption:
  exists-trace
  "
    Ex t pd p #i. Trustee_Partial_Decryption_Trace(t, pd, p)@i
  "
dnl Include the proof script, if one exists.
sinclude(PROOF_SCRIPT)dnl

/*
  This lemma states that it is possible to reach a state where a single
  trustee has declared a partial decryption invalid.

  Tamarin can verify this lemma automatically, but it takes a decent
  amount of time. If a proof script is available for <!!>TRUSTEE_COUNT<!!> trustees
  with a threshold of <!!>TRUSTEE_THRESHOLD<!!>, it can be included
  below.
 */
define(<!PROOF_SCRIPT!>, ifdef(<!INCLUDE_PROOF_SCRIPTS!>, <!subprotocols/includes/proofs/TrusteeDecryption_One_Invalid_Partial_Decryption_Detection_<!!>TRUSTEE_COUNT<!!>_<!!>TRUSTEE_THRESHOLD<!!>.spthy.inc!>, <!/tmp/NOPROOFSCRIPT!>))dnl
syscmd(cat PROOF_SCRIPT > /dev/null 2>&1)dnl
lemma ifelse(sysval, <!0!>, <!ProofScript!>, <!NoProofScript!>)_Executability_TrusteeDecryption_One_Invalid_Partial_Decryption_Detection:
  exists-trace
  "
    Ex t pd_t #i.
    (
        Trustee_Detect_Invalid_Partial_Decryption_Trace(t, pd_t)@i
      &
        not (t = pd_t)
    )
  "
dnl Include the proof script, if one exists.
sinclude(PROOF_SCRIPT)dnl

/*
  This lemma states that it is possible to reach a state where the
  trustee Decryption subprotocol is complete.

  Tamarin can verify this lemma automatically, but it takes a decent
  amount of time. If a proof script is available for <!!>TRUSTEE_COUNT<!!> trustees
  with a threshold of <!!>TRUSTEE_THRESHOLD<!!>, it can be included
  below.
 */
define(<!PROOF_SCRIPT!>, ifdef(<!INCLUDE_PROOF_SCRIPTS!>, <!subprotocols/includes/proofs/TrusteeDecryption_Complete_<!!>TRUSTEE_COUNT<!!>_<!!>TRUSTEE_THRESHOLD<!!>.spthy.inc!>, <!/tmp/NOPROOFSCRIPT!>))dnl
syscmd(cat PROOF_SCRIPT > /dev/null 2>&1)dnl
lemma ifelse(sysval, <!0!>, <!ProofScript!>, <!NoProofScript!>)_Executability_TrusteeDecryption_Complete:
  exists-trace
  "
      (
        Ex b #i. TAS_TrusteeDecryption_Complete_Trace(b)@i
      )
    &
      not (
        Ex t m s #i. InjectTrusteeMsg(t, m, s)@i
      )
  "
dnl Include the proof script, if one exists.
sinclude(PROOF_SCRIPT)dnl
