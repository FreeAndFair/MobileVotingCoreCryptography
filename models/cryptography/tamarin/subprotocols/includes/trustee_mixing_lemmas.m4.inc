/* Lemmas for trustee mixing subprotocol. */

/* Sources Lemma */

/*
  This is a translation of the sources lemma generated by Tamarin's
  --auto-sources. It works, but takes a lot of precomputation
  memory, and it's not clear how well it would scale to higher
  numbers of trustees.

  Tamarin can verify this lemma automatically, but it takes a decent
  amount of time. If a proof script is available for <!!>TRUSTEE_COUNT<!!> trustees
  with a <!!>TRUSTEE_THRESHOLD<!!> trustee threshold, it can be included
  below.
 */
define(<!PROOF_SCRIPT!>, ifdef(<!INCLUDE_PROOF_SCRIPTS!>, <!subprotocols/includes/proofs/Sources_TrusteeMixing_<!!>TRUSTEE_COUNT<!!>_<!!>TRUSTEE_THRESHOLD<!!>.spthy.inc!>, <!/tmp/NOPROOFSCRIPT!>))dnl
syscmd(cat PROOF_SCRIPT > /dev/null 2>&1)dnl
lemma ifelse(sysval, <!0!>, <!ProofScript!>, <!NoProofScript!>)_Sources_TrusteeMixing [sources]:
  "
      (All a b c d e #i.
            IN_TRUSTEE_BBENTRY(a, b, c, d, e)@i
        ==>
            (Ex #j.
              (
                  OUT_TRUSTEE_BBENTRY(a, b, c, d, e)@j
                &
                  #j < #i
              )
            )
      )
    &
      (All x m #i.
            IN_SHUFFLE_ORDER_TERM(m, x)@i
        ==>
            (
                (Ex #j.
                  (
                      KU(x)@j
                    &
                      #j < #i
                  )
                )
              |
                (Ex #j.
                  (
                      OUT_SHUFFLE_ORDER_TERM(m)@j
                    &
                      #j < #i
                  )
                )
            )
      )
    &
      (All x m #i.
            IN_SHUFFLE_PROOF_TERM(m, x)@i
        ==>
            (
                (Ex #j.
                  (
                      KU(x)@j
                    &
                      #j < #i
                  )
                )
              |
                (Ex #j.
                  (
                      OUT_SHUFFLE_PROOF_TERM(m)@j
                    &
                      #j < #i
                  )
                )
            )
      )
    &
      (All x m #i.
            IN_BALLOTSET_C1_TERM(m, x)@i
        ==>
            (
                (Ex #j.
                  (
                      KU(x)@j
                    &
                      #j < #i
                  )
                )
              |
                (Ex #j.
                  (
                      OUT_BALLOTSET_C1_TERM(m)@j
                    &
                      #j < #i
                  )
                )
            )
      )
    &
      (All x m #i.
            IN_BALLOTSET_C2_TERM(m, x)@i
        ==>
            (
                (Ex #j.
                  (
                      KU(x)@j
                    &
                      #j < #i
                  )
                )
              |
                (Ex #j.
                  (
                      OUT_BALLOTSET_C2_TERM(m)@j
                    &
                      #j < #i
                  )
                )
            )
      )
    &
      (All x m #i.
            IN_BALLOTSET_P_TERM(m, x)@i
        ==>
            (
                (Ex #j.
                  (
                      KU(x)@j
                    &
                      #j < #i
                  )
                )
              |
                (Ex #j.
                  (
                      OUT_BALLOTSET_P_TERM(m)@j
                    &
                      #j < #i
                  )
                )
            )
      )
  "
dnl Include the proof script, if one exists.
sinclude(PROOF_SCRIPT)dnl

/* Protocol Safety Lemmas */

/*
  This lemma states that the only valid trustee names are the
  <!!>TRUSTEE_COUNT<!!> that start with 'Trustee' (this includes
  'Trustee0' for this subprotocol).
 */
lemma Safety_TrusteeMixing_Valid_Trustee_Names [reuse]:
  "
    All tn pk_sign pk_encrypt #i.
          TAS_Trustee_Trace(tn, pk_sign, pk_encrypt)@i
      ==>
forloop(<!TN!>, <!0!>, TRUSTEE_COUNT, <!            tn = 'Trustee<!!>TN<!!>'<!!>ifelse(eval(TN < TRUSTEE_COUNT), eval(1), <!
          |
!>)!>)
  "

/*
  This lemma states that each trustee name only has one associated
  identity.
 */
lemma Safety_TrusteeMixing_Only_One_Identity_Per_Trustee [reuse]:
  "
    All tr sk1 sk2 pk1 pk2 #i1 #i2.
            TAS_Trustee_Trace(tr, sk1, pk1)@i1
          &
            TAS_Trustee_Trace(tr, sk2, pk2)@i2
      ==>
          sk1 = sk2 & pk1 = pk2
  "

/*
  This lemma states that all trustees and the TAS agree on the election
  setup (it is redundant with a lemma from the election setup protocol
  but is provided here for Tamarin's reuse).
 */
lemma Safety_TrusteeMixing_UniqueElectionSetup [reuse]:
  "
    All tr es1 es2 es3 #i1 #i2 #j.
          TAS_ElectionSetup_Complete_Trace(es1)@i1
        &
          TAS_ElectionSetup_Complete_Trace(es2)@i2
        &
          Trustee_ElectionSetup_Trace(tr, es3)@j
      ==>
          es1 = es2 & es1 = es3 & es2 = es3
  "

/*
  This lemma states that all TAS BB messages, except the root message,
  come from one of the <!!>TRUSTEE_COUNT<!!> trustees (or are injected
  with their signature).
 */
lemma Safety_TrusteeMixing_TAS_BB_Message_Sources [reuse]:
  "
    All sd sl msg sig %idx #i.
            TAS_BBEntry_Trace(sd, sl, msg, sig, %idx)@i
      ==>
forloop(<!TN!>, <!0!>, TRUSTEE_COUNT, <!            sd = 'Trustee<!!>TN<!!>'<!!>ifelse(eval(TN < TRUSTEE_COUNT), eval(1), <!
          |
!>)!>)
  "

/*
  This lemma states that no two TAS trustee board messages have the
  same index.
 */
lemma Safety_TrusteeMixing_TAS_BB_No_Duplicate_Indices [reuse]:
  "
    All tr1 tr2 mt1 mt2 msg1 msg2 sig1 sig2 %idx #i1 #i2.
            TAS_BBEntry_Trace(tr1, mt1, msg1, sig1, %idx)@i1
          &
            TAS_BBEntry_Trace(tr2, mt2, msg2, sig2, %idx)@i2
      ==>
          tr1 = tr2 & mt1 = mt2 & msg1 = msg2 & sig1 = sig2 & #i1 = #i2
  "

/*
  This lemma states that all BB messages on the TAS trustee board
  have distinct event times.
 */
lemma Safety_TrusteeMixing_TAS_BB_Distinct_Timestamps [reuse]:
  "
    All sd1 sd2 sl1 sl2 msg1 msg2 sig1 sig2 %idx1 %idx2 #i1 #i2.
            TAS_BBEntry_Trace(sd1, sl1, msg1, sig1, %idx1)@i1
          &
            TAS_BBEntry_Trace(sd2, sl2, msg2, sig2, %idx2)@i2
          &
            not (%idx1 = %idx2)
          &
            #i1 = #i2
      ==>
          F
  "

/*
  This lemma states that every entry on the TAS trustee board, other
  than the root message, is from a registered trustee and has a
  valid signature.
 */
lemma Safety_TrusteeMixing_TAS_BB_Message_Validity [reuse]:
  "
    All tr mt msg sig %idx #i.
            TAS_BBEntry_Trace(tr, mt, msg, sig, %idx)@i
      ==>
          (Ex pk_sign pk_encrypt param sk #j #k.
              TAS_Trustee_Trace(tr, pk_sign, pk_encrypt)@j
            &
              HonestSignatureKey(pk_sign)@k
            &
              pk(sk) = pk_sign
            &
              sig = sign(msg, param, sk)
          )
  "

/*
  This lemma states that there is at most one message in each slot
  from each trustee on the TAS trustee board, unless one was injected.
 */
lemma Safety_TrusteeMixing_TAS_BB_No_Duplicate_Slots [reuse, hide_lemma=Safety_TrusteeMixing_Valid_Trustee_Names, hide_lemma=Safety_TrusteeMixing_TAS_BB_Message_Sources]:
  "
    All sd sl msg1 msg2 sig1 sig2 %idx1 %idx2 #i1 #i2.
            TAS_BBEntry_Trace(sd, sl, msg1, sig1, %idx1)@i1
          &
            TAS_BBEntry_Trace(sd, sl, msg2, sig2, %idx2)@i2
      ==>
            (msg1 = msg2 & sig1 = sig2 & %idx1 = %idx2 & #i1 = #i2)
          |
            (Ex #j. InjectTrusteeMsg(sd, msg1, sig1)@j)
          |
            (Ex #j. InjectTrusteeMsg(sd, msg2, sig2)@j)
  "

/*
  This lemma states that all trustee BB messages, except the root message,
  come from one of the <!!>TRUSTEE_COUNT<!!> trustees - including trustee
  0 - or are injected with their signature.
 */
lemma Safety_TrusteeMixing_Trustee_BBs_Message_Sources [reuse]:
  "
    All tr sd sl msg sig %idx #i.
            Trustee_BBEntry_Trace(tr, sd, sl, msg, sig, %idx)@i
      ==>
forloop(<!TN!>, <!0!>, TRUSTEE_COUNT, <!            sd = 'Trustee<!!>TN<!!>'<!!>ifelse(eval(TN < TRUSTEE_COUNT), eval(1), <!
          |
!>)!>)
  "

/*
  This lemma states that each trustee's local trustee board
  follows the TAS trustee board; i.e., it has exactly the same
  sequence of messages up until the trustee's local board ends,
  which may be before the TAS trustee board ends depending on
  the legality of the message sequence on the TAS trustee board
  and whether the local trustee board has caught up.
 */
lemma Safety_TrusteeMixing_Trustee_BBs_Follow_TAS [reuse]:
  "
    All tr sd1 sd2 sl1 sl2 msg1 msg2 sig1 sig2 %idx #i1 #i2.
            Trustee_BBEntry_Trace(tr, sd1, sl1, msg1, sig1, %idx)@i1
          &
            TAS_BBEntry_Trace(sd2, sl2, msg2, sig2, %idx)@i2
      ==>
          sd1 = sd2 & sl1 = sl2 & msg1 = msg2 & sig1 = sig2
  "

/*
  This lemma states that all the local trustee boards have the same
  message sequence, as far as they all go (it is effectively another
  way of stating that all the trustee BBs follow the TAS BB),
  but it may help Tamarin to state it separately.
 */
lemma Safety_TrusteeMixing_Trustee_BBs_Match [reuse]:
  "
    All tr1 tr2 sd1 sd2 sl1 sl2 msg1 msg2 sig1 sig2 %idx #i1 #i2.
            Trustee_BBEntry_Trace(tr1, sd1, sl1, msg1, sig1, %idx)@i1
          &
            Trustee_BBEntry_Trace(tr2, sd2, sl2, msg2, sig2, %idx)@i2
      ==>
          sd1 = sd2 & sl1 = sl2 & msg1 = msg2 & sig1 = sig2
  "

/*
  This lemma states that there is at most one message in each slot
  from each trustee on each trustee's local board.
 */
lemma Safety_TrusteeMixing_Trustee_BBs_No_Duplicate_Slots [reuse]:
  "
    All tr sd sl msg1 msg2 sig1 sig2 %idx1 %idx2 #i1 #i2.
            Trustee_BBEntry_Trace(tr, sd, sl, msg1, sig1, %idx1)@i1
          &
            Trustee_BBEntry_Trace(tr, sd, sl, msg2, sig2, %idx2)@i2
      ==>
          msg1 = msg2 & sig1 = sig2 & %idx1 = %idx2 & #i1 = #i2
  "

/*
  This lemma states that all BB messages on local trustee boards
  have distinct event times.
 */
lemma Safety_TrusteeMixing_Trustee_BBs_Distinct_Timestamps [reuse]:
  "
    All tr sd1 sd2 sl1 sl2 msg1 msg2 sig1 sig2 %idx1 %idx2 #i1 #i2.
            Trustee_BBEntry_Trace(tr, sd1, sl1, msg1, sig1, %idx1)@i1
          &
            Trustee_BBEntry_Trace(tr, sd2, sl2, msg2, sig2, %idx2)@i2
          &
            not (%idx1 = %idx2)
          &
            #i1 = #i2
      ==>
          F
  "

/*
  This lemma states that each trustee shuffles at most once.
 */
lemma Safety_TrusteeMixing_At_Most_One_Shuffle_Each [reuse]:
  "
    All tr so1 bs1 sp1 #i1 so2 bs2 sp2 #i2.
            Trustee_Shuffle_Trace(tr, so1, bs1, sp1)@i1
          &
            Trustee_Shuffle_Trace(tr, so2, bs2, sp2)@i2
      ==>
          so1 = so2 & bs1 = bs2 & sp1 = sp2 & #i1 = #i2
  "

/*
  This lemma states that each trustee signs at most one shuffle
  from each other trustee.
 */
lemma Safety_TrusteeMixing_At_Most_One_Sig_Per_Shuffle [reuse]:
  "
    All tr st #i1 #i2.
            Trustee_Sign_Shuffle_Trace(tr, st)@i1
          &
            Trustee_Sign_Shuffle_Trace(tr, st)@i2
      ==>
          #i1 = #i2
  "

/*
  Protocol Executability Lemmas

  Note that these are verified without reusing any lemmas that Tamarin
  cannot verify automatically or that do not have proof scripts, so
  they are all valid despite some of the safety lemmas not having been
  verified.
*/

/*
  This lemma states that it is possible to reach a state where the
  initial set of ballots has been posted.
 */
lemma Executability_TrusteeMixing_Initial_Ballots_Posted:
  exists-trace
  "
    Ex c #i. TAS_TrusteeMixing_Init_Trace(c)@i
  "

/*
  This lemma states that it is possible to reach a state where the
  initial set of ballots has been found to have valid proofs by a
  single trustee.
 */
define(<!PROOF_SCRIPT!>, ifdef(<!INCLUDE_PROOF_SCRIPTS!>, <!subprotocols/includes/proofs/TrusteeMixing_Ballot_Proofs_Checked_Valid_<!!>TRUSTEE_COUNT<!!>_<!!>TRUSTEE_THRESHOLD<!!>.spthy.inc!>, <!/tmp/NOPROOFSCRIPT!>))dnl
syscmd(cat PROOF_SCRIPT > /dev/null 2>&1)dnl
lemma ifelse(sysval, <!0!>, <!ProofScript!>, <!NoProofScript!>)_Executability_TrusteeMixing_Ballot_Proofs_Checked_Valid:
  exists-trace
  "
    Ex t b #i. Trustee_Check_Encryption_Proofs_Success_Trace(t, b)@i
  "
dnl Include the proof script, if one exists.
sinclude(PROOF_SCRIPT)dnl

/*
  This lemma states that it is possible to reach a state where the
  initial set of ballots has been found to have invalid proofs by a
  single trustee.
 */
define(<!PROOF_SCRIPT!>, ifdef(<!INCLUDE_PROOF_SCRIPTS!>, <!subprotocols/includes/proofs/TrusteeMixing_Ballot_Proofs_Checked_Invalid_<!!>TRUSTEE_COUNT<!!>_<!!>TRUSTEE_THRESHOLD<!!>.spthy.inc!>, <!/tmp/NOPROOFSCRIPT!>))dnl
syscmd(cat PROOF_SCRIPT > /dev/null 2>&1)dnl
lemma ifelse(sysval, <!0!>, <!ProofScript!>, <!NoProofScript!>)_Executability_TrusteeMixing_Ballot_Proofs_Checked_Invalid:
  exists-trace
  "
    Ex t b #i. Trustee_Check_Encryption_Proofs_Failure_Trace(t, b)@i
  "
dnl Include the proof script, if one exists.
sinclude(PROOF_SCRIPT)dnl

/*
  This lemma states that it is possible to reach a state where a single
  trustee has shuffled the ballots and at least one other trustee has
  signed the shuffle. We restrict this to be in the absence of adversary
  message injection to reduce the search space.

  Tamarin can verify this lemma automatically, but it takes a decent
  amount of time. If a proof script is available for <!!>TRUSTEE_COUNT<!!> trustees
  with a <!!>TRUSTEE_THRESHOLD<!!> trustee threshold, it can be included
  below.
 */
define(<!PROOF_SCRIPT!>, ifdef(<!INCLUDE_PROOF_SCRIPTS!>, <!subprotocols/includes/proofs/TrusteeMixing_One_Shuffle_<!!>TRUSTEE_COUNT<!!>_<!!>TRUSTEE_THRESHOLD<!!>.spthy.inc!>, <!/tmp/NOPROOFSCRIPT!>))dnl
syscmd(cat PROOF_SCRIPT > /dev/null 2>&1)dnl
lemma ifelse(sysval, <!0!>, <!ProofScript!>, <!NoProofScript!>)_Executability_TrusteeMixing_One_Shuffle:
  exists-trace
  "
      (
        Ex t1 t2 o s p #i #j.
        (
            Trustee_Shuffle_Trace(t1, o, s, p)@i
          &
            Trustee_Sign_Shuffle_Trace(t2, t1)@j
          &
            not (t1 = t2)
        )
      )
    &
      not (
        Ex t m s #i. InjectTrusteeMsg(t, m, s)@i
      )
  "
dnl Include the proof script, if one exists.
sinclude(PROOF_SCRIPT)dnl

/*
  This lemma states that it is possible to reach a state where a single
  trustee has declared a shuffle invalid.

  Tamarin can verify this lemma automatically, but it takes a decent
  amount of time. If a proof script is available for <!!>TRUSTEE_COUNT<!!> trustees
  with a <!!>TRUSTEE_THRESHOLD<!!> trustee threshold, it can be included
  below.
 */
define(<!PROOF_SCRIPT!>, ifdef(<!INCLUDE_PROOF_SCRIPTS!>, <!subprotocols/includes/proofs/TrusteeMixing_One_Invalid_Shuffle_Detection_<!!>TRUSTEE_COUNT<!!>_<!!>TRUSTEE_THRESHOLD<!!>.spthy.inc!>, <!/tmp/NOPROOFSCRIPT!>))dnl
syscmd(cat PROOF_SCRIPT > /dev/null 2>&1)dnl
lemma ifelse(sysval, <!0!>, <!ProofScript!>, <!NoProofScript!>)_Executability_TrusteeMixing_One_Invalid_Shuffle_Detection:
  exists-trace
  "
    Ex t sh si #i.
    (
        Trustee_Detect_Invalid_Shuffle_Trace(t, sh, si)@i
      &
        not (t = sh)
    )
  "
dnl Include the proof script, if one exists.
sinclude(PROOF_SCRIPT)dnl

/*
  This lemma states that it is possible to reach a state where the
  trustee mixing subprotocol is complete. We restrict this to be in
  the absence of adversary message injection to reduce the search
  space.

  Tamarin can verify this lemma automatically, but it takes a decent
  amount of time. If a proof script is available for <!!>TRUSTEE_COUNT<!!> trustees
  with a <!!>TRUSTEE_THRESHOLD<!!> trustee threshold, it can be included
  below.
 */
define(<!PROOF_SCRIPT!>, ifdef(<!INCLUDE_PROOF_SCRIPTS!>, <!subprotocols/includes/proofs/TrusteeMixing_Complete_<!!>TRUSTEE_COUNT<!!>_<!!>TRUSTEE_THRESHOLD<!!>.spthy.inc!>, <!/tmp/NOPROOFSCRIPT!>))dnl
syscmd(cat PROOF_SCRIPT > /dev/null 2>&1)dnl
lemma ifelse(sysval, <!0!>, <!ProofScript!>, <!NoProofScript!>)_Executability_TrusteeMixing_Complete:
  exists-trace
  "
      (
        Ex b s p #i. TAS_TrusteeMixing_Complete_Trace(b, s, p)@i
      )
    &
      not (
        Ex t m s #i. InjectTrusteeMsg(t, m, s)@i
      )
  "
dnl Include the proof script, if one exists.
sinclude(PROOF_SCRIPT)dnl
