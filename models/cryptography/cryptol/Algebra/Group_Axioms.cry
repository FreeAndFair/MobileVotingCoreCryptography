/**
 * Verifies that applicable group axioms are satisfied by
 * a given implementation of the GroupI interface.
 *
 * To perform verification, instantiate this module with the
 * implementation of the GroupI interface to be verified.
 * Then, load the resp. instantiation into cryptol and use the
 * :check-docstring command to try and prove all properties
 * defined in this module.
 *
 * @author Frank Zeyda (frank.zeyda@freeandfair.us)
 * @copyright Free & Fair 2025
 * @version 0.1
 */
module Algebra::Group_Axioms where

import interface Algebra::GroupI

import Algebra::GroupUtils { interface GroupI }

import Algebra::Set

/**
 * For convenience, we defined e and infix syntax
 * for equality, multiplication and exponentiation
 * within the group. This makes the Cryptol model
 * more closely aligned with a mathematical text.
 */
infix 20 ≡
private (≡) = T'eq
private (∘) = gop
private (^) = exp
private e = identity

/*************************/
/* Auxiliary Definitions */
/*************************/

/**
 * Specification of Exponentiation (generic exponent)
 *
 * The group's exp operation is verified against the
 * canonical specification of exponentiation below.
 *
 * This version of generic exponentiation is expressed
 * solely in term of the Ring constants and functions
 * of E. It is very slow as it does not implement the
 * faster _exponentiation by squares_ method.
 *
 * @todo fzeyda Discuss with the rest of the team whether
 * there exists a fast exponentiation method that works
 * more generally on Rings or Fields.
 *
 * @caveat This property is not suitable for verifying
 * exponentiation in direct products groups, as there are
 * exponents for which the function may not terminate.
 * For direct products, use exp'specN or exp'specZ below.
 */
exp'spec : T -> E -> T
exp'spec x n =
  if n == zero then identity
  else (exp'spec x (n - one)) ∘ x
  where one = (fromInteger 1) : E

/**
 * Specification of Exponentiation (Integer exponent)
 *
 * The group's derived expN operation is verified against
 * the canonical specification of exponentiation below.
 */
exp'specN : T -> Integer -> T
exp'specN x n =
  if n == 0 then identity
  | n < 0 then inv (exp'specN x (-n))
  else (
    if n % 2 == 0 then y ∘ y
    else x ∘ y ∘ y
    where y = exp'specN x (n / 2)
  )

/**
 * Specification of Exponentiation (Integer exponent)
 *
 * The group's derived expN operation is verified against
 * the canonical specification of exponentiation below.
 */
exp'specZ : T -> (Z order) -> T
exp'specZ x n = exp'specN x (fromZ n)

/****************/
/* Group Axioms */
/****************/

/**
 * The identity element is a member of the carrier G.
 */
property identity_in_G =
  e ∈ G

/**
 * The carrier G is closed under the group operation.
 */
property G_closed_under_gop x y =
  x ∈ G /\ y ∈ G ==> x ∘ y ∈ G

/**
 * The carrier G is closed under inverse construction.
 */
property G_closed_under_inv x =
  x ∈ G ==> (inv x) ∈ G

/**
 * The carrier G is closed under exponentiation.
 */
property G_closed_under_exp x (k : E) =
  x ∈ G ==> x^k ∈ G

/**
 * The carrier G is closed under exponentiation.
 *
 * Accepts exponents of type `Integer`. Here, we
 * use the derived exponentiation function expN.
 */
property G_closed_under_expN x (n : Integer) =
  x ∈ G ==> expN x n ∈ G

/**
 * The carrier G is closed under exponentiation.
 *
 * Accepts exponents of type `Z order`. Here, we
 * use the derived exponentiation function expZ.
 */
property G_closed_under_expZ x (z : Z order) =
  x ∈ G ==> expZ x z ∈ G

/**
 * The group operation is associative.
 */
property associative x y z =
  x ∈ G /\ y ∈ G /\ z ∈ G ==>
  (x ∘ y) ∘ z ≡ x ∘ (y ∘ z)

/**
 * The group operation is commutative.
 *
 * @note fzeyda: Douglas Wikström mentioned that all groups we use
 * are expected to be commutative, hence Abelian groups. So this is
 * a mandatory property to prove, though it is not clear to me yet
 * where it is actually relied upon.
 */
property commutative x y =
  x ∈ G /\ y ∈ G ==> x ∘ y ≡ y ∘ x

/**
 * The identity element is a valid left identity.
 */
property left_identity x =
  x ∈ G ==> e ∘ x ≡ x

/**
 * The identity element is a valid right identity.
 */
property right_identity x =
  x ∈ G ==> x ∘ e ≡ x

/**
 * The identity element is both a valid left identity
 * and a valid right identity.
 */
property valid_identity x =
  left_identity x /\ right_identity x

/**
 * The inverse function yields a valid left inverse.
 */
property left_inverse x =
  x ∈ G ==> (inv x) ∘ x ≡ e

/**
 * The inverse function yields a valid right inverse.
 */
property right_inverse x =
  x ∈ G ==> x ∘ (inv x) ≡ e

/**
 * The inverse function yields a valid inverse.
 */
property valid_inverse x =
  left_inverse x /\ right_inverse x

/**
 * Exponentiation is defined correctly wrt its specification.
 *
 * @caveat Not applicable to direct product groups.
 */
property exp_correct x (k : E) =
  x ∈ G ==> exp x k ≡ exp'spec x k

/**
 * Exponentiation is defined correctly wrt its specification.
 *
 * This version of exp_correct limits exponents to numbers in
 * the range from -128 to 127.
 *
 * @caveat Not applicable to direct product groups.
 */
property exp_correct_small_exponents x (bv : [8]) =
  x ∈ G ==> exp x k ≡ exp'spec x k
  where k = fromInteger (toSignedInteger bv)

/**
 * Exponentiation is defined correctly wrt its specification.
 *
 * Here, we verify the derived operation `expN` in GroupUtils.
 *
 * @note This version is applicable to direct product groups too.
 */
property expN_correct x (n : Integer) =
  x ∈ G ==> expN x n ≡ exp'specN x k
  where k = fromInteger n

/**
 * Exponentiation is defined correctly wrt its specification.
 *
 * Here, we verify the derived operation `expZ` in GroupUtils.
 *
 * @note This version is applicable to direct product groups too.
 */
property expZ_correct x (z : Z order) =
  x ∈ G ==> expZ x z ≡ exp'specN x k
  where k = fromInteger (fromZ z)

/**
 * Decoding an encoded bitvector gives back the same value.
 *
 * @note There is no property: `x ∈ G ==> enc (dec x) ≡ x`
 * since not all group elements may be in the range of the
 * `enc` function.
 */
property enc_dec_inverse (bv : [bits]) =
  dec (enc bv) == bv

/**
 * Random generation of group elements is correct (sound).
 *
 * @note It is outside the reasoning scope of Cryptol
 * to prove any probabilistic properties of `gen`;
 * i.e., related to the resulting output distribution
 * based on the distribution of bitvector inputs.
 */
property gen_in_G (bv : [rngbits]) =
  (gen bv) ∈ G
