/**
 * Algebraic Group with a Carrier Set (Interface)
 *
 * Note that since not all elements of the underlying
 * type universe T may be valid group elements, group
 * operators are conceptually partial. There are
 * different ways to deal with partiality and we adopt
 * the approach of HOL which is logically the simplest:
 * functions applied outside their domain yield a value
 * of the correct type but we do not have any knowledge
 * of that value and therefore cannot prove anything
 * about it at the specification level.
 *
 * This, however, puts a constraint on implementations
 * to ensure that group operations are well behaved even
 * if applied to a nonmember of the group (x ∉ G). This
 * means they must always terminate and yield a value of
 * the correct type, and not crash or panic, regardless
 * of the elements to which they are applied.
 *
 * @note Currently not used by the rest of the models as
 * we cannot import one Cryptol interface in another.
 *
 * @author Frank Zeyda (frank.zeyda@freeandfair.us)
 * @copyright Free & Fair 2025
 * @version 0.1
 */
interface module Algebra::GroupI where

import Algebra::Set
import Algebra::Utils(lg2floor)

/**
 * Order of the group
 *
 * This corresponds to the number of valid group
 * elements, being the cardinality of the set G.
 */
type order : #
type constraint (fin order, order >= 1)

/**
 * Bits allotted to encode a group element
 *
 * This type is used by the domain and codomain of the
 * `enc` and `dec` functions.
 *
 * @note We previously used a looser type constraint
 * `bits <= lg2 order` here, which meant that some
 * bitstrings may not be encodable. Douglas Wikström
 * recommended that the `enc` function ought be total.
 * Hence, whenever `order` is not a power of 2, we
 * necessarily throw a few group elements away.
 *
 * @note There may be other reasons for `bits` to be
 * strictly less than `lg2floor order`, even if
 * the group order is a power of 2. E.g., encoding
 * schemes for elliptic curves typically require a
 * certain number of _twiddle bits_ to find a valid
 * curve point, see Neal Koblitz's paper, Sect. 3:
 * @see https://evervault.com/papers/koblitz.pdf
 */
type bits : #
type constraint (fin bits, bits > 0, bits <= lg2floor order)

/**
 * Bits used to generate a random group element
 *
 * @note Douglas Wikström noted that we need at least
 * `lg2 order` bits from the random source to satisfy
 * safety properties of the resulting probability
 * distribution of group elements. More are fine too!
 */
type rngbits : #
type constraint (fin rngbits, rngbits >= lg2 order)

/**
 * Type universe of group elements
 *
 * @note Previously I had a type constraint Eq T here
 * but this turned out to be too strong since not all
 * user-defined types by default implement Eq a and
 * there currently is no way to implement it manually.
 * @todo Rename T into G (for Group) or U (for Universe)?
 */
type T : *
// type constraint (Eq T)

/**
 * Generic exponent type
 *
 * For generic definition of exponentiation we require
 * the exponent type to be a member of Cryptol's Ring
 * class. Since the Ring class includes a function
 * fromInteger : {a} (Ring a) => Integer -> Ring a,
 * we can easily derive a function that uses integer
 * exponents from the generic exponentiation below,
 * see the `GroupUtils` module.
 *
 * Note that `Eq E` is additionally required to provide
 * a generic recursive definition of exponentiation in
 * the `Group_Axioms` module against which we can verify
 * the definition of exp in concrete groups.
 *
 * @note Douglas Wikström encouraged exploration of using
 * a constraint (Field E) for the exponent type. Sadly,
 * unlike Ring, the Field type class lacks instantiations
 * for product and list types. This would prevent us from
 * instantiating E with a tuple or product type, i.e, in
 * direct product groups. (I understand that user-level
 * instantiation of type classes is currently not supported
 * in Cryptol.)
 *
 * Alternatively, we may not impose any type constraint
 * on E here. While this precludes a generic (canonical)
 * definition of exponentiation, concrete instances of
 * GroupI can always provide their own definition.
 *
 * @note Douglas Wikström also recommended using `Z order`
 * as a monomorphic exponent type. However, this would not
 * allow us to instantiate E suitably for product groups,
 * unless we provide a mapping from `Z order` to tuples.
 */
type E : *
type constraint (Ring E, Eq E)

/**
 * Equality of group elements
 *
 * Since not all Cryptol types implement the Eq type
 * class by default, for generality, the group instance
 * has to define an equality test function on type T.
 */
T'eq : T -> T -> Bool

/**
 * Carrier set of the group
 *
 * Defines the values of type T that are valid group
 * elements.
 */
G : Set T

/**
 * Identity element of the group
 *
 * Must be a valid group element (identity ∈ G).
 */
identity : T

/**
 * Binary group operation
 *
 * The group operation must be closed under the set G.
 * That is, if x ∈ G and y ∈ G then (gop x y) ∈ G.
 *
 * @review Do we usually expect gop to be commutative?
 */
gop : T -> T -> T

/**
 * Inverse of a given group element
 *
 * The standard group axioms merely require the
 * existence of an inverse but we need to be able
 * to compute it, so implementations must define
 * the below function.
 *
 * Inverse must be closed under the set G.
 * That is, if x ∈ G then (inv x) ∈ G.
 */
inv : T -> T

/**
 * Repeated application of group operation
 *
 * We assume that G is closed under exponentiation
 * for all elements of type E and all valid group
 * elements of type T. That is, for x ∈ G and
 * k : E, we have (exp x k) ∈ G.
 *
 * To handle negative exponents when applicable
 * for type E, exp shall moreover obey the identity:
 * (exp x k) == (exp (inv x) (-k)) for x ∈ G.
 * Naturally, we also require (exp x 0) == identity
 * and (exp x 1) == x for all x ∈ G.
 */
exp : T -> E -> T

/**
 * Encoding a message as a group element
 *
 * This function defines a default encoding of a
 * bitstring of predefined length `bits` into a
 * group element if there is an obvious canonical
 * way to do so.
 */
enc : [bits] -> T

/**
 * Decoding a group element into a message
 *
 * If the given group element e is in the
 * range of the `enc` function, its unique
 * bitvector representation shall be returned.
 * Otherwise, the result may be any value and
 * is considered to be undefined.
 */
dec : T -> [bits]

/**
 * Generation of a random group element from a (random)
 * bitstring.
 */
gen : [rngbits] -> T

/* @note fzeyda: Initially, I used `Integer` to
 * uniformly represent messages to be encoded but
 * later decided to change this to bit strings.
 * This has some advantages over integers in terms
 * of Rust code generation and also enables one to
 * restrict permissible messages at the type level. */
